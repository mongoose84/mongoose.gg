# .github/workflows/deploy-api.yml
name: Server - ASP .NET API CI & Deploy

# -------------------------------------------------
# When to run
# -------------------------------------------------
on:
  push:
    branches: [main]
    paths:
      - 'server/**'          # only trigger when API code changes
  workflow_dispatch:         # manual trigger from the UI

# -------------------------------------------------
# Job definition
# -------------------------------------------------
jobs:
  build-and-deploy:
    runs-on: windows-latest               # needed for win‑x86 runtime
    concurrency:
      group: server-prod-deploy
      cancel-in-progress: true
    env:
      # Folder where `dotnet publish` will drop the files
      PUBLISH_DIR: publish-output  
      
    defaults:
      # Every `run:` step will start in the project folder
      run:
        working-directory: server

    steps:
      # -------------------------------------------------
      # Checkout the repo
      # -------------------------------------------------
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # needed for versioning tools


      # (Removed early offline toggle to avoid leaving site offline if build fails)

      # -------------------------------------------------
      # Set up .NET SDK
      # -------------------------------------------------
      - name: Set up .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.x'          # matches TargetFramework net9.0

      # -------------------------------------------------
      # Restore NuGet packages (optional but clearer logs)
      # -------------------------------------------------
      - name: Restore dependencies
        run: dotnet restore

      # -------------------------------------------------
      # Validate required secrets are set
      # -------------------------------------------------
      - name: Validate required secrets
        shell: pwsh
        run: |
          $missingSecrets = @()
          
          if ([string]::IsNullOrWhiteSpace("${{ secrets.LOL_DB_CONNECTIONSTRING_V2 }}")) {
            $missingSecrets += "LOL_DB_CONNECTIONSTRING_V2"
          }
          if ([string]::IsNullOrWhiteSpace("${{ secrets.RIOT_API_KEY }}")) {
            $missingSecrets += "RIOT_API_KEY"
          }
          if ([string]::IsNullOrWhiteSpace("${{ secrets.ENCRYPTION_SECRET }}")) {
            $missingSecrets += "ENCRYPTION_SECRET"
          }

          if ($missingSecrets.Count -gt 0) {
            Write-Error "❌ Missing required GitHub secrets: $($missingSecrets -join ', ')"
            Write-Error "Please add these secrets in: Settings → Secrets and variables → Actions"
            Write-Error "Required format:"
            Write-Error "  - LOL_DB_CONNECTIONSTRING_V2: Server=host;Port=3306;Database=db_v2;User=user;Password=pass"
            Write-Error "  - RIOT_API_KEY: RGAPI-xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
            Write-Error "  - ENCRYPTION_SECRET: Base64-encoded 32-byte key (use: openssl rand -base64 32)"
            exit 1
          }
          
          Write-Host "✅ All required secrets are configured"

      # -------------------------------------------------
      # Create appsettings.Production.json with secrets
      # This file will be deployed and read by the app at runtime
      # -------------------------------------------------
      - name: Generate appsettings.Production.json
        shell: pwsh
        run: |
          $json = @{
            "Logging" = @{
              "LogLevel" = @{
                "Default" = "Warning"
                "Microsoft.AspNetCore" = "Warning"
              }
            }
            "AllowedHosts" = "*"
            "ConnectionStrings" = @{
              "DatabaseV2" = "${{ secrets.LOL_DB_CONNECTIONSTRING_V2 }}"
            }
            "Riot" = @{
              "ApiKey" = "${{ secrets.RIOT_API_KEY }}"
            }
            "Auth" = @{
              "CookieName" = "mongoose-auth"
              "SessionTimeout" = 30
              "EnableMvpLogin" = $false
            }
            "Jobs" = @{
              "EnableMatchHistorySync" = $true
            }
            "Security" = @{
              "EncryptionSecret" = "${{ secrets.ENCRYPTION_SECRET }}"
            }
          } | ConvertTo-Json -Depth 10
          
          Set-Content -Path "appsettings.Production.json" -Value $json
          Write-Host "✅ appsettings.Production.json generated successfully (contents hidden for security)"

      # -------------------------------------------------
      # Run server unit tests (including auth hardening)
      # -------------------------------------------------
      - name: Run tests
        run: dotnet test ../lol.sln --configuration Release --logger "trx;LogFileName=test-results.trx"

      # -------------------------------------------------
      # Publish a **self‑contained** Windows‑x86 binary
      # -------------------------------------------------
      - name: Publish (self-contained)
        run: |
          dotnet publish -c Release -r win-x86 --self-contained=true  -o ./${{ env.PUBLISH_DIR }}
      
      # -------------------------------------------------
      # Verify publish output exists and show its contents
      # -------------------------------------------------
      - name: Verify publish output
        shell: pwsh
        run: |
          if (-not (Test-Path "./${{ env.PUBLISH_DIR }}")) {
            Write-Error "Publish output folder './${{ env.PUBLISH_DIR }}' not found"
            exit 1
          }
          Write-Host "=== Files that will be uploaded ==="
          Get-ChildItem -Recurse "./${{ env.PUBLISH_DIR }}"

      # -------------------------------------------------
      # Enter maintenance mode right before deploy (idempotent, with retries)
      # -------------------------------------------------
      - name: Bring site offline (upload app_offline.htm)
        id: bring-offline
        shell: pwsh
        run: |
          $maxAttempts = 3
          $remoteBase = "ftp://${{ secrets.FTP_URL }}/${{ secrets.FTP_SERVER_PATH }}"
          $remoteOffline = "$remoteBase/app_offline.htm"
          $localOffline = "./CI-Support/app_offline.htm"

          # If the site is already offline, do not fail—just skip the upload
          $alreadyOffline = $false
          curl -s --ssl -u "${{ secrets.FTP_USERNAME }}:${{ secrets.FTP_PASSWORD }}" `
            "$remoteOffline" > $null 2>&1
          if ($LASTEXITCODE -eq 0) { $alreadyOffline = $true }

          if ($alreadyOffline) {
            Write-Host "⚠️ app_offline.htm already present at root; skipping upload."
          }
          else {
            for ($i = 1; $i -le $maxAttempts; $i++) {
              Write-Host "Attempt ${i}: Uploading app_offline.htm to remote root"
              curl -v --ssl -u "${{ secrets.FTP_USERNAME }}:${{ secrets.FTP_PASSWORD }}" `
                -T $localOffline `
                "$remoteOffline"
              
              if ($LASTEXITCODE -eq 0) {
                Write-Host "✅ Maintenance mode enabled"
                "site_offline=true" >> $env:GITHUB_OUTPUT
                break
              }
              elseif ($i -eq $maxAttempts) {
                Write-Error "❌ Failed to enable maintenance mode after $maxAttempts attempts"
                exit 1
              }
              else {
                $delay = 5 * $i
                Write-Warning "Upload failed, retrying in $delay seconds..."
                Start-Sleep -Seconds $delay
              }
            }
          }
          # If already offline, also set the output so we bring it back online
          if ($alreadyOffline) {
            "site_offline=true" >> $env:GITHUB_OUTPUT
          }

      # -------------------------------------------------
      # Deploy new files via FTPS (publish folder only)
      # -------------------------------------------------
      - name: Deploy new files to FTP server
        uses: SamKirkland/FTP-Deploy-Action@v4.3.4
        with:
          server: ${{ secrets.FTP_URL }}
          username: ${{ secrets.FTP_USERNAME }}
          password: ${{ secrets.FTP_PASSWORD }}
          protocol: ftps
          port: 21
          # Point to the SAME folder we just verified
          local-dir: ./server/${{ env.PUBLISH_DIR }}/
          # NOTE: The exclusion patterns below may be redundant. RiotProxy.csproj already
          # excludes RiotProxy.Tests content via Compile Remove, EmbeddedResource Remove,
          # and None Remove directives. Since the tests project is separate and should not
          # be included in the publish output by dotnet publish, these FTP patterns are
          # likely unnecessary. Consider removing if verification confirms test files are
          # not present in the publish folder.
          exclude: |
            RiotProxy.Tests/**
            **/RiotProxy.Tests/**
          server-dir: ${{ secrets.FTP_SERVER_PATH }}
          # optional safety flags
          # dry-run: false
          # timeout: 30

      # --------------------------------------------------------------
      # Bring site back online only if it was taken offline
      # --------------------------------------------------------------
      - name: Bring site back online (delete app_offline.htm)
        if: ${{ always() && steps.bring-offline.outputs.site_offline == 'true' }}
        shell: pwsh
        run: |
          $maxAttempts = 3
          $remoteBase = "ftp://${{ secrets.FTP_URL }}/${{ secrets.FTP_SERVER_PATH }}"
          $remoteOffline = "$remoteBase/app_offline.htm"
          $remoteSupportDir = "${{ secrets.FTP_SERVER_PATH }}/CI-Support"
          $remoteSupportTarget = "$remoteBase/CI-Support/app_offline.htm"
          $moveSucceeded = $false

          # Ensure the CI-Support folder exists on the remote (ignore errors if it already exists)
          curl -s --ssl -u "${{ secrets.FTP_USERNAME }}:${{ secrets.FTP_PASSWORD }}" `
            "$remoteBase" `
            -Q "MKD $remoteSupportDir" > $null 2>&1
          Write-Host "CI-Support folder creation attempt completed (may already exist)."

          # Best-effort delete of any existing target to avoid RNTO collisions
          curl -s --ssl -u "${{ secrets.FTP_USERNAME }}:${{ secrets.FTP_PASSWORD }}" `
            "$remoteBase" `
            -Q "DELE $remoteSupportDir/app_offline.htm" > $null 2>&1
          Write-Host "Target cleanup attempt completed (file may not exist)."

          for ($i = 1; $i -le $maxAttempts; $i++) {
            Write-Host "Attempt ${i}: Moving app_offline.htm from root back to CI-Support"
            curl -v --ssl -u "${{ secrets.FTP_USERNAME }}:${{ secrets.FTP_PASSWORD }}" `
              "$remoteBase" `
              -Q "RNFR ${{ secrets.FTP_SERVER_PATH }}/app_offline.htm" `
              -Q "RNTO $remoteSupportDir/app_offline.htm" 2>&1 | Out-Null

            if ($LASTEXITCODE -eq 0) {
              Write-Host "✅ Maintenance mode disabled (file moved to CI-Support)"
              $moveSucceeded = $true
              break
            }
            elseif ($LASTEXITCODE -eq 21) {
              # Exit code 21 = "FTP quote error" which typically indicates the source file was not found
              # (RNFR failed because app_offline.htm doesn't exist in root). This is acceptable—it means
              # the site is already online. However, exit code 21 can have other meanings depending on the
              # FTP server and curl version, so this check may need adjustment if false positives occur.
              # Alternative: parse stderr or expand exit code checks to include other "not found" codes.
              Write-Warning "app_offline.htm not found or already moved; treating as already online"
              $moveSucceeded = $true
              break
            }
            elseif ($i -eq $maxAttempts) {
              Write-Warning "⚠️ Failed to move app_offline.htm after $maxAttempts attempts; site may remain offline"
              break
            }
            else {
              $delay = 5 * $i
              Write-Warning "Move failed with exit code $LASTEXITCODE, retrying in $delay seconds..."
              Start-Sleep -Seconds $delay
            }
          }

          # Only succeed if we explicitly handled the condition; otherwise fail
          if (-not $moveSucceeded) {
            Write-Error "Maintenance mode could not be disabled; pipeline failing to alert operators"
            exit 1
          }

